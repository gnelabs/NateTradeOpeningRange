#Author: Nathan ward

AWSTemplateFormatVersion: '2010-09-09'
Transform: AWS::Serverless-2016-10-31
Description: Opening range trading strategy, parallel backtesting system.

Globals:
  Function:
    #Documentation and other DeploymentPreference Types can be found here: https://github.com/awslabs/serverless-application-model/blob/master/docs/safe_lambda_deployments.rst
    AutoPublishAlias: live
    DeploymentPreference:
      Type: AllAtOnce
  Api:
    BinaryMediaTypes:
      #The ~1 will be replaced with / when deployed
      - '*~1*'

Parameters:
  AttachLambdaFunctionToVPC: { Type: String, Default: 'false', AllowedValues: ['true', 'false']}
  Stage: {Type: String, Default: 'prod'}
  ServiceName: {Type: String, Default: 'NateTradeOpeningRange'}

Conditions:
  RunLambdaInVPC:
    Fn::Equals: [ {Ref: AttachLambdaFunctionToVPC}, "true"]
  IsProd:
    Fn::Equals:
      - Ref: Stage
      - prod

#CIDR subnet mappings of available IP addresses in the VPC.
Mappings:
  SubnetConfig:
    VPC:
      CIDR: '10.0.0.0/16'
    PublicOne:
      CIDR: '10.0.0.0/24'
    PublicTwo:
      CIDR: '10.0.1.0/24'

Resources:
  ################### Networking Resources ###################
  #Setup the VLAN and VPC for containers to run in. This is required
  #to use Elasticache with low latency networking.

  #VPC for virtual machines to be able to access Redis
  VPC:
    Type: AWS::EC2::VPC
    Properties:
      EnableDnsSupport: true
      EnableDnsHostnames: true
      CidrBlock: !FindInMap ['SubnetConfig', 'VPC', 'CIDR']

  #Internet gateway is required to give containers access to
  #the internet, if needed.
  InternetGateway:
    Type: AWS::EC2::InternetGateway
  GatewayAttachement:
    Type: AWS::EC2::VPCGatewayAttachment
    Properties:
      VpcId: !Ref 'VPC'
      InternetGatewayId: !Ref 'InternetGateway'
  PublicRouteTable:
    Type: AWS::EC2::RouteTable
    Properties:
      VpcId: !Ref 'VPC'
  PublicRoute:
    Type: AWS::EC2::Route
    DependsOn: GatewayAttachement
    Properties:
      RouteTableId: !Ref 'PublicRouteTable'
      DestinationCidrBlock: '0.0.0.0/0'
      GatewayId: !Ref 'InternetGateway'
  PublicSubnetOneRouteTableAssociation:
    Type: AWS::EC2::SubnetRouteTableAssociation
    Properties:
      SubnetId: !Ref PublicSubnetOne
      RouteTableId: !Ref PublicRouteTable
  PublicSubnetTwoRouteTableAssociation:
    Type: AWS::EC2::SubnetRouteTableAssociation
    Properties:
      SubnetId: !Ref PublicSubnetTwo
      RouteTableId: !Ref PublicRouteTable

  #Two public subnets, where containers can have public IP addresses.
  PublicSubnetOne:
    Type: AWS::EC2::Subnet
    Properties:
      AvailabilityZone:
         Fn::Select:
         - 0
         - Fn::GetAZs: {Ref: 'AWS::Region'}
      VpcId: {Ref: VPC}
      CidrBlock: !FindInMap ['SubnetConfig', 'PublicOne', 'CIDR']
      MapPublicIpOnLaunch: true
  PublicSubnetTwo:
    Type: AWS::EC2::Subnet
    Properties:
      AvailabilityZone:
         Fn::Select:
         - 1
         - Fn::GetAZs: {Ref: 'AWS::Region'}
      VpcId: {Ref: VPC}
      CidrBlock: !FindInMap ['SubnetConfig', 'PublicTwo', 'CIDR']
      MapPublicIpOnLaunch: true

  ################### Elasticache Redis ###################
  #Resources and permissions to setup the Redis database.

  #Subnet group to control where the Redis gets placed
  RedisSubnetGroup:
    Type: AWS::ElastiCache::SubnetGroup
    Properties:
      Description: Group of subnets to place Redis into
      SubnetIds:
        - {Ref: PublicSubnetOne}
        - {Ref: PublicSubnetTwo}

  #Security group to add Redis cluster to the VPC.
  RedisSecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupDescription: "Redis Security Group"
      VpcId: {Ref: VPC}

  #Allow Redis to be accessed on the default port by anything inside the VPC.
  RedisIngress:
    Type: AWS::EC2::SecurityGroupIngress
    Properties:
      Description: Ingress to access Redis.
      GroupId: {Ref: RedisSecurityGroup}
      IpProtocol: tcp
      FromPort: 6379
      ToPort: 6379
      SourceSecurityGroupId: !GetAtt 'RedisSecurityGroup.GroupId'

  #Security group that acts as a placeholder for load balancers.
  LoadBalancerSecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupDescription: "Load Balancer Security Group"
      VpcId: {Ref: VPC}

  #Public redis access. No security concern since this load balancer only exists during testing.
  OpenRedisAccessLoadBalancer:
    Type: AWS::EC2::SecurityGroupIngress
    Properties:
      Description: Open and unrestricted Redis access for the load balancer.
      GroupId: {Ref: LoadBalancerSecurityGroup}
      IpProtocol: tcp
      FromPort: 6379
      ToPort: 6379
      CidrIp: 0.0.0.0/0

  #Allow Redis to be accessed from the load balancer.
  LoadBalancerIngress:
    Type: AWS::EC2::SecurityGroupIngress
    Properties:
      Description: Ingress to access Redis from the Load Balancer.
      GroupId: {Ref: RedisSecurityGroup}
      IpProtocol: tcp
      FromPort: 6379
      ToPort: 6379
      SourceSecurityGroupId: !GetAtt 'LoadBalancerSecurityGroup.GroupId'

  ################### ECS Cluster ###################
  #ECS cluster used to run processing machines for crunching numbers.

  #ECS Cluster
  ECSCluster:
    Type: AWS::ECS::Cluster
    Properties:
      ClusterName: NateTradeOpeningRange
      CapacityProviders:
        - FARGATE
        - FARGATE_SPOT
      DefaultCapacityProviderStrategy:
        - CapacityProvider: FARGATE
        - CapacityProvider: FARGATE_SPOT
      ClusterSettings:
        - Name: containerInsights
          Value: enabled

  #General purpose role needed by ECS and lambda to start tasks.
  ExecutionRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: !Join ['', [!Ref ServiceName, ExecutionRole]]
      AssumeRolePolicyDocument:
        Statement:
          - Effect: Allow
            Principal:
              Service: ecs-tasks.amazonaws.com
            Action: 'sts:AssumeRole'
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: 'sts:AssumeRole'
      ManagedPolicyArns:
        - 'arn:aws:iam::aws:policy/service-role/AmazonECSTaskExecutionRolePolicy'

  #ECR repo for docker images.
  OpeningRangeRepo:
    Type: AWS::ECR::Repository
    Properties:
      RepositoryName: 'natetrade/opening_range'

  ################### ECS Task ###################
  #This contains the task definition and logging needed to run contaniers.
  #These containers will run a celery worker to consume requests and 
  #do number crunching, returning the result back to redis.
  #These are unoptimized.

  #Log group for ECS.
  LogGroupOpeningRange:
    Type: AWS::Logs::LogGroup
    Properties:
      LogGroupName: !Join ['', [/ecs/, !Ref ServiceName, OpeningRange]]
      RetentionInDays: 30

  #Task definition.
  TaskDefinitionOpeningRange:
    Type: AWS::ECS::TaskDefinition
    # Makes sure the log group is created before it is used.
    DependsOn: LogGroupOpeningRange
    Properties:
      Family: !Join ['', [!Ref ServiceName, OpeningRange]]
      NetworkMode: awsvpc
      RequiresCompatibilities:
        - FARGATE
      Cpu: 1024
      Memory: 2GB
      ExecutionRoleArn: { 'Fn::GetAtt' : ExecutionRole.Arn}
      TaskRoleArn: !Ref TaskRoleOpeningRange
      ContainerDefinitions:
        - Name: !Join ['', [!Ref ServiceName, OpeningRange]]
          Image: { 'Fn::Join' : [ ':', [ { 'Fn::GetAtt' : OpeningRangeRepo.RepositoryUri}, 'latest']]}
          LogConfiguration:
            LogDriver: awslogs
            Options:
              awslogs-region: !Ref AWS::Region
              awslogs-group: !Ref LogGroupOpeningRange
              awslogs-stream-prefix: ecs
          Environment:
            - Name: 'CELERY_QUEUE_NAME'
              Value: 'worker_main'

  #Permissions for the ECS tasks.
  TaskRoleOpeningRange:
    Type: AWS::IAM::Role
    Properties:
      RoleName: !Join ['', [!Ref ServiceName, TaskRoleOpeningRange]]
      AssumeRolePolicyDocument:
        Statement:
          - Effect: Allow
            Principal:
              Service: ecs-tasks.amazonaws.com
            Action: 'sts:AssumeRole'
      Policies:
        #Dynamodb access to read and write to multiple tables.
        - PolicyName: !Join ['', [!Ref ServiceName, TaskRoleOpeningRange, DDBFull]]
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - dynamodb:*
                Resource: {'Fn::Sub': 'arn:aws:dynamodb:${AWS::Region}:${AWS::AccountId}:*'}

Outputs:
  StackArn:
    Description: "Use this as the stack_arn in your cloud_formation_deployment_stack override."
    Value: {Ref: 'AWS::StackId'}
  RedisSecurityGroupId:
    Description: "Redis cluster security group ID."
    Value: !GetAtt 'RedisSecurityGroup.GroupId'
    Export: {Name: {'Fn::Sub': '${AWS::StackName}-RedisSecurityGroupId'}}
  RedisSubnetGroupName:
    Description: "Redis cluster subnet group name."
    Value: {Ref: RedisSubnetGroup}
    Export: {Name: {'Fn::Sub': '${AWS::StackName}-RedisSubnetGroupName'}}
  VPCSubnetIDOne:
    Description: "VPC subnet ID one."
    Value: {Ref: PublicSubnetOne}
    Export: {Name: {'Fn::Sub': '${AWS::StackName}-VPCSubnetIDOne'}}
  VPCSubnetIDTwo:
    Description: "VPC subnet ID two."
    Value: {Ref: PublicSubnetTwo}
    Export: {Name: {'Fn::Sub': '${AWS::StackName}-VPCSubnetIDTwo'}}
  LBSecurityGroupId:
    Description: "Load balancer security group ID."
    Value: !GetAtt 'LoadBalancerSecurityGroup.GroupId'
    Export: {Name: {'Fn::Sub': '${AWS::StackName}-LoadBalancerSecurityGroupId'}}
  VPCId:
    Description: "VPC ID."
    Value: {Ref: VPC}
    Export: {Name: {'Fn::Sub': '${AWS::StackName}-VPCId'}}